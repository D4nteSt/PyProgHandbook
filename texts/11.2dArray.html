<h1>Двумерные массивы</h1>
<ol>
    <li>
        <h2>Обработка и вывод вложенных списков</h2>
        <p>
            Часто в задачах приходится хранить прямоугольные таблицы с данными.
            Такие таблицы называются матрицами или двумерными массивами.
            В языке программирования Питон таблицу можно представить в виде списка строк, каждый элемент которого является в свою очередь списком, например, чисел.
            Например, приведём программу, в которой создаётся числовая таблица из двух строк и трех столбцов, с которой производятся различные действия.
        </p>
        <p><img src="images\2dArraySRC\img1.png"></p>
        <p>
            Здесь первая строка списка <b>a[0]</b> является списком из чисел <b>[1, 2, 3]</b>. То есть <b>a[0][0] == 1</b>, значение <b>a[0][1] == 2</b>, <b>a[0][2] == 3</b>, <b>a[1][0] == 4</b>, <b>a[1][1] == 5</b>, <b>a[1][2] == 6</b>.
        </p>
        <p>
            Для обработки и вывода списка, как правило, используют два вложенных цикла.
            Первый цикл перебирает номер строки, второй цикл бежит по элементам внутри строки.
            Например, вывести двумерный числовой список на экран построчно, разделяя числа пробелами внутри одной строки, можно так:
        </p>
        <p><img src="images\2dArraySRC\img2.png"></p>
        <p>
            Ранее упоминалось, что переменная цикла <b>for</b> в Питоне может перебирать не только диапазон, создаваемый с помощью функции <b>range()</b>, но и вообще перебирать любые элементы любой последовательности.
            Продемонстрируем, как выводить двумерный массив, используя это удобное свойство цикла <b>for</b>:
        </p>
        <p><img src="images\2dArraySRC\img3.png"></p>
        <p>
            Естественно, для вывода одной строки можно воспользоваться методом <b>join()</b>:
        </p>
        <p><img src="images\2dArraySRC\img4.png"></p>
        <p>
            Используем два вложенных цикла для подсчета суммы всех чисел в списке:
        </p>
        <p><img src="images\2dArraySRC\img5.png"></p>
        <p>
            Или то же самое с циклом не по индексу, а по значениям строк:
        </p>
        <p><img src="images\2dArraySRC\img6.png"></p>
    </li>
    <li>
        <h2>Создание вложенных списков</h2>
        <p>
            Пусть даны два числа: количество строк <b>n</b> и количество столбцов <b>m</b>. Необходимо создать список размером <b>n×m</b>, заполненный нулями.
        </p>
        <p>Очевидное решение оказывается неверным:</p>
        <p><img src="images\2dArraySRC\img7.png"></p>
        <p>
            В этом легко убедиться, если присвоить элементу <b>a[0][0]</b> значение 5, а потом вывести значение другого элемента <b>a[1][0]</b> — оно тоже будет равно 5.
            Дело в том, что <b>[0] * m</b> возвращает ссылку на список из <b>m</b> нулей.
            Но последующее повторение этого элемента создает список из <b>n</b> элементов, которые являются ссылкой на один и тот же список (точно так же, как выполнение операции <b>b = a</b> для списков не создает новый список), поэтому все строки результирующего списка на самом деле являются одной и той же строкой.
        </p>
        <p>
            В визуализаторе обратите внимание на номер id у списков. Если у двух списков id совпадает, то это на самом деле один и тот же список в памяти.
        </p>
        <p><img src="images\2dArraySRC\img8.png"></p>
        <p>
            Таким образом, двумерный список нельзя создавать при помощи операции повторения одной строки. Что же делать?
        </p>
        <p>
            Первый способ: сначала создадим список из n элементов (для начала просто из <b>n</b> нулей).
            Затем сделаем каждый элемент списка ссылкой на другой одномерный список из <b>m</b> элементов:
        </p>
        <p><img src="images\2dArraySRC\img9.png"></p>
        <p>
            Другой (но похожий) способ: создать пустой список, потом n раз добавить в него новый элемент, являющийся списком-строкой:
        </p>
        <p><img src="images\2dArraySRC\img10.png"></p>
        <p>
            Но еще проще воспользоваться генератором: создать список из <b>n</b> элементов, каждый из которых будет списком, состоящих из <b>m</b> нулей: 
        </p>
        <p><img src="images\2dArraySRC\img11.png"></p>
        <p>
            В этом случае каждый элемент создается независимо от остальных (заново конструируется список <b>[0] * m</b> для заполнения очередного элемента списка), а не копируются ссылки на один и тот же список.
        </p>
    </li>
    <li>
        <h2>Ввод двумерного массива</h2>
        <p>
            Пусть программа получает на вход двумерный массив в виде <b>n</b> строк, каждая из которых содержит <b>m</b> чисел, разделенных пробелами. Как их считать? Например, так:
        </p>
        <p><img src="images\2dArraySRC\img12.png"></p>
        <p>
            Или, без использования сложных вложенных вызовов функций:
        </p>
        <p><img src="images\2dArraySRC\img13.png"></p>
        <p>
            Можно сделать то же самое и при помощи генератора:
        </p>
        <p><img src="images\2dArraySRC\img14.png"></p>
    </li>
    <li>
        <h2>Пример обработки двумерного массива</h2>
        <p>
            Пусть дан квадратный массив из <b>n</b> строк и <b>n</b> столбцов.
            Необходимо элементам, находящимся на главной диагонали, проходящей из левого верхнего угла в правый нижний (то есть тем элементам <b>a[i][j]</b>, для которых <b>i==j</b>) присвоить значение 1, элементам, находящимся выше главной диагонали – значение 0, элементам, находящимся ниже главной диагонали – значение 2.
            То есть необходимо получить такой массив (пример для <b>n==4</b>):
        </p>
        <p><img src="images\2dArraySRC\img15.png"></p>
        <p>
            Рассмотрим несколько способов решения этой задачи. Элементы, которые лежат выше главной диагонали – это элементы <b>a[i][j]</b>, для которых <b>i &lt; j</b>, а для элементов ниже главной диагонали <b>i &gt; j</b>.
            Таким образом, мы можем сравнивать значения <b>i и j</b> и по ним определять значение <b>A[i][j]</b>.
            Получаем следующий алгоритм:
        </p>
        <p><img src="images\2dArraySRC\img16.png"></p>
        <p>
            Данный алгоритм плох, поскольку выполняет одну или две инструкции <b>if</b> для обработки каждого элемента.
            Если мы усложним алгоритм, то мы сможем обойтись вообще без условных инструкций.
        </p>
        <p>
            Сначала заполним главную диагональ, для чего нам понадобится один цикл:
        </p>
        <p><img src="images\2dArraySRC\img17.png"></p>
        <p>
            Затем заполним значением 0 все элементы выше главной диагонали, для чего нам понадобится в каждой из строк с номером <b>i</b> присвоить значение элементам <b>a[i][j] для j=i+1, ..., n-1</b>.
            Здесь нам понадобятся вложенные циклы:
        </p>
        <p><img src="images\2dArraySRC\img18.png"></p>
        <p>
            Аналогично присваиваем значение 2 элементам <b>a[i][j] для j=0, ..., i-1</b>:
        </p>
        <p><img src="images\2dArraySRC\img19.png"></p>
        <p>
            Можно также внешние циклы объединить в один и получить еще одно, более компактное решение:
        </p>
        <p><img src="images\2dArraySRC\img20.png"></p>
        <p>
            А вот такое решение использует операцию повторения списков для построения очередной строки списка. <b>i-я</b> строка списка состоит из <b>i</b> чисел 2, затем идет одно число 1, затем идет <b>n-i-1</b> число 0:
        </p>
        <p><img src="images\2dArraySRC\img21.png"></p>
        <p>
            А можно заменить цикл на генератор:
        </p>
        <p><img src="images\2dArraySRC\img22.png"></p>
    </li>
    <li>
        <h2>Вложеные генераторы двумерных массивов</h2>
        <p>
            Для создания двумерных массивов можно использовать вложенные генераторы, разместив генератор списка, являющегося строкой, внутри генератора всех строк.
            Напомним, что сделать список из <b>n</b> строк и <b>m</b> столбцов можно при помощи генератора, создающего список из <b>n</b> элементов, каждый элемент которого является списком из <b>m</b> нулей:
        </p>
        <p><img src="images\2dArraySRC\img23.png"></p>
        <p>
            Но при этом внутренний список также можно создать при помощи, например, такого генератора: <b>[0 for j in range(m)]</b>.
            Вложив один генератор в другой, получим вложенные генераторы:
        </p>
        <p><img src="images\2dArraySRC\img24.png"></p>
        <p>
            Но если число 0 заменить на некоторое выражение, зависящее от <b>i</b> (номер строки) и <b>j</b> (номер столбца), то можно получить список, заполненный по некоторой формуле.
        </p>
        <p>
            Например, пусть нужно задать следующий массив (для удобства добавлены дополнительные пробелы между элементами):
        </p>
        <p><img src="images\2dArraySRC\img25.png"></p>
        <p>
            В этом массиве <b>n = 5</b> строк, <b>m = 6</b> столбцов, и элемент в строке <b>i</b> и столбце <b>j</b> вычисляется по формуле: <b>a[i][j] = i * j</b>.
        </p>
        <p>
            Для создания такого массива можно использовать генератор:
        </p>
        <p><img src="images\2dArraySRC\img26.png"></p>
    </li>
</ol>