<style>
    table, th, tr, td {
        border: 1px solid black;
        border-collapse: collapse;
    }
    table {
        table-layout: fixed;
    }
    th, td, tr {
        height: 30px;
    }
</style>

<h1>Множества</h1>
<p>
    Множество в языке Питон — это структура данных, эквивалентная множествам в математике.
    Множество может состоять из различных элементов, порядок элементов в множестве не определен.
    В множество можно добавлять и удалять элементы, можно перебирать элементы множества, можно выполнять операции над множествами (объединение, пересечение, разность).
    Можно проверять принадлежность элемента множеству.
</p>
<p>
    В отличие от массивов, где элементы хранятся в виде последовательного списка, в множествах порядок хранения элементов не определен (более того, элементы множества хранятся не подряд, как в списке, а при помощи хитрых алгоритмов).
    Это позволяет выполнять операции типа “проверить принадлежность элемента множеству” быстрее, чем просто перебирая все элементы множества.
</p>
<p>
    Элементами множества может быть любой неизменяемый тип данных: числа, строки, кортежи.
    Изменяемые типы данных не могут быть элементами множества, в частности, нельзя сделать элементом множества список (но можно сделать кортеж) или другое множество.
    Требование неизменяемости элементов множества накладывается особенностями представления множества в памяти компьютера.
</p>
<ol>
    <li>
        <h2>Задание множеств</h2>
        <p>
            Множество задается перечислением всех его элементов в фигурных скобках.
            Исключением является пустое множество, которое можно создать при помощи функции set().
            Если функции set передать в качестве параметра список, строку или кортеж, то она вернёт множество, составленное из элементов списка, строки, кортежа.
            Например:
        </p>
        <p><img src="images\setSRC\img1.png"></p>
        <p>
            выведет <b>{'e', 'q', 'r', 't', 'w', 'y'}</b>.
        </p>
        <p>
            Каждый элемент может входить в множество только один раз, порядок задания элементов неважен.
            Например, программа:
        </p>
        <p><img src="images\setSRC\img2.png"></p>
        <p>
            выведет <b>True</b>, так как <b>A</b> и <b>B</b> — равные множества.
        </p>
        <p>
            Каждый элемент может входить в множество только один раз. <b>set('Hello')</b> вернет множество из четырех элементов: <b>{'H', 'e', 'l', 'o'}</b>.
        </p>
    </li>
    <li>
        <h2>Работа с элементами множеств</h2>
        <p>Узнать число элементов в множестве можно при помощи функции <b>len</b>.</p>
        <p>
            Перебрать все элементы множества (в неопределенном порядке!) можно при помощи цикла <b>for</b>:
        </p>
        <p><img src="images\setSRC\img3.png"></p>
        <p>
            Проверить, принадлежит ли элемент множеству можно при помощи операции <b>in</b>, возвращающей значение типа <b>bool</b>.
            Аналогично есть противоположная операция <b>not in</b>.
            Для добавления элемента в множество есть метод <b>add</b>:
        </p>
        <p><img src="images\setSRC\img4.png"></p>
        <p>
            Для удаления элемента x из множества есть два метода: <b>discard</b> и <b>remove</b>.
            Их поведение различается только в случае, когда удаляемый элемент отсутствует в множестве.
            В этом случае метод <b>discard</b> не делает ничего, а метод <b>remove</b> генерирует исключение <b>KeyError</b>.
        </p>
        <p>
            Наконец, метод <b>pop</b> удаляет из множества один случайный элемент и возвращает его значение. Если же множество пусто, то генерируется исключение <b>KeyError</b>.
        </p>
        <p>
            Из множества можно сделать список при помощи функции <b>list</b>.
        </p>
    </li>
    <li>
        <h2>Операции с множествами</h2>
        <p>С множествами в питоне можно выполнять обычные для математики операции над множествами.</p>
        <table>
            <tr>
                <td><b>A | B <br>
                    A.union(B)
                    </b></td>
                <td>
                    Возвращает множество, являющееся объединением множеств A и B.
                </td>
            </tr>
            <tr>
                <td><b>A |= B <br>
                    A.update(B)
                    </b></td>
                <td>
                    Добавляет в множество A все элементы из множества B.
                </td>
            </tr>
            <tr>
                <td><b>A & B <br>
                    A.intersection(B)
                    </b></td>
                <td>
                    Возвращает множество, являющееся пересечением множеств A и B.
                </td>
            </tr>
            <tr>
                <td><b>A &= B <br>
                    A.intersection_update(B)
                    </b></td>
                <td>
                    Оставляет в множестве A только те элементы, которые есть в множестве B.
                </td>
            </tr>
            <tr>
                <td><b>A - B <br>
                    A.difference(B)
                    </b></td>
                <td>
                    Возвращает разность множеств A и B (элементы, входящие в A, но не входящие в B).
                </td>
            </tr>
            <tr>
                <td><b>A -= B <br>
                    A.difference_update(B)
                    </b></td>
                <td>
                    Удаляет из множества A все элементы, входящие в B.
                </td>
            </tr>
            <tr>
                <td><b>A ^ B <br>
                    A.symmetric_difference(B)
                    </b></td>
                <td>
                    Возвращает симметрическую разность множеств A и B (элементы, входящие в A или в B, но не в оба из них одновременно).
                </td>
            </tr>
            <tr>
                <td><b>A ^= B <br>
                    A.symmetric_difference_update(B)
                    </b></td>
                <td>
                    Записывает в A симметрическую разность множеств A и B.
                </td>
            </tr>
            <tr>
                <td><b>A &lt;= B <br>
                    A.issubset(B)
                    </b></td>
                <td>
                    Возвращает true, если A является подмножеством B.
                </td>
            </tr>
            <tr>
                <td><b>A &gt;= B <br>
                    A.issuperset(B)
                    </b></td>
                <td>
                    Возвращает true, если B является подмножеством A.
                </td>
            </tr>
            <tr>
                <td><b>A &lt; B</b></td>
                <td>
                    Эквивалентно A &lt;= B and A != B
                </td>
            </tr>
            <tr>
                <td><b>A &gt; B</b></td>
                <td>
                    Эквивалентно A &gt;= B and A != B
                </td>
            </tr>
        </table>
    </li>
</ol>