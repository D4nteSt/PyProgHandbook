<style>
    table, th, tr, td {
        border: 1px solid black;
        border-collapse: collapse;
    }
    table {
        table-layout: fixed;
    }
    th, td, tr {
        height: 30px;
    }
</style>

<h1>Списки</h1>
<p>
    Большинство программ работает не с отдельными переменными, а с набором переменных.
    Например, программа может обрабатывать информацию об учащихся класса, считывая список учащихся с клавиатуры или из файла, при этом изменение количества учащихся в классе не должно требовать модификации исходного кода программы.
</p>
<p>
    Раньше мы сталкивались с задачей обработки элементов последовательности, например, вычисляя наибольший элемент последовательности.
    Но при этом мы не сохраняли всю последовательность в памяти компьютера.
    Однако, во многих задачах нужно именно сохранять всю последовательность, например, если бы нам требовалось вывести все элементы последовательности в возрастающем порядке (“отсортировать последовательность”). 
</p>
<p>
    Для хранения таких данных можно использовать структуру данных, называемую в Питоне <i>список</i> (в большинстве же языков программирования используется другой термин <i>“массив”</i>).
    Список представляет собой последовательность элементов, пронумерованных от 0, как символы в строке.
    Список можно задать перечислением элементов списка в квадратных скобках, например, список можно задать так:
</p>
<p><img src="images\listSRC\img1.png"></p>
<p>
    В списке <b>Primes</b> — 6 элементов, а именно: <b>Primes[0] == 2</b>, <b>Primes[1] == 3</b>, <b>Primes[2] == 5</b>, <b>Primes[3] == 7</b>, <b>Primes[4] == 11</b>, <b>Primes[5] == 13</b>.
    Список <b>Rainbow</b> состоит из 7 элементов, каждый из которых является строкой.
</p>
<p>
    Также как и символы в строке, элементы списка можно индексировать отрицательными числами с конца, например, <b>Primes[-1] == 13</b>, <b>Primes[-6] == 2</b>.
</p>
<p>
    Длину списка, то есть количество элементов в нем, можно узнать при помощи функции <b>len</b>, например, <b>len(Primes) == 6</b>.
</p>
<p>В отличие от строк, элементы списка можно изменять, присваивая им новые значения.</p>
<p><img src="images\listSRC\img2.png"></p>
<p>
    Рассмотрим несколько способов создания и считывания списков.
    Прежде всего, можно создать пустой список (не содержащий элементов, длины 0), а в конец списка можно добавлять элементы при помощи метода <b>append</b>.
    Например, пусть программа получает на вход количество элементов в списке n, а потом n элементов списка по одному в отдельной строке.
    Вот пример входных данных в таком формате:
</p>
<p><img src="images\listSRC\img3.png"></p>
<p>
    В этом примере создается пустой список, далее считывается количество элементов в списке, затем по одному считываются элементы списка и добавляются в его конец.
    То же самое можно записать, сэкономив переменную <b>n</b>
</p>
<p><img src="images\listSRC\img4.png"></p>
<p>
    Для списков целиком определены следующие операции: конкатенация списков (сложение списков, т. е. приписывание к одному списку другого) и повторение списков (умножение списка на число).
    Например:
</p>
<p><img src="images\listSRC\img5.png"></p>
<p>
    Это позволяет по-другому организовать процесс считывания списков: сначала считать размер списка и создать список из нужного числа элементов, затем организовать цикл по переменной <b>i</b> начиная с числа 0 и внутри цикла считывается <b>i-й</b> элемент списка:
</p>
<p><img src="images\listSRC\img6.png"></p>
<p>
    Вывести элементы списка a можно одной инструкцией <b>print(a)</b>, при этом будут выведены квадратные скобки вокруг элементов списка и запятые между элементами списка. 
    Такой вывод неудобен, чаще требуется просто вывести все элементы списка в одну строку или по одному элементу в строке.
    Приведем два примера, также отличающиеся организацией цикла:
</p>
<p><img src="images\listSRC\img7.png"></p>
<p>
    Здесь в цикле меняется индекс элемента <b>i</b>, затем выводится элемент списка с индексом <b>i</b>.
</p>
<p><img src="images\listSRC\img8.png"></p>
<p>
    В этом примере элементы списка выводятся в одну строку, разделенные пробелом, при этом в цикле меняется не индекс элемента списка, а само значение переменной. Например, в цикле <b>for elem in ['red', 'green', 'blue']</b> переменная <b>elem</b> будет последовательно принимать значения <b>'red', 'green', 'blue'</b>.
</p>
<p>
    Обратите особое внимание на последний пример!
    Очень важная часть идеологии Питона — это цикл <b>for</b>, который предоставляет удобный способ перебрать все элементы некоторой последовательности.
    В этом отличие Питона от Паскаля, где вам обязательно надо перебирать именно <i>индексы</i> элементов, а не сами элементы.
</p>
<p>
    Последовательностями в Питоне являются строки, списки, значения функции <b>range()</b> (это не списки), и ещё кое-какие другие объекты.
</p>
<p>
    Приведем пример, демонстрирующий использование цикла <b>for</b> в ситуации, когда из строки надо выбрать все цифры и сложить их в массив как числа.
</p>
<p><img src="images\listSRC\img9.png"></p>
<ol>
    <li>
        <h2>Методы split и join</h2>
        <p>
            Элементы списка могут вводиться по одному в строке, в этом случае строку целиком можно считать функцией <b>input()</b>.
            После этого можно использовать метод строки <b>split()</b>, возвращающий список строк, которые получатся, если исходную строку разрезать на части по пробелам.
            Пример:  
        </p>
        <p><img src="images\listSRC\img10.png"></p>
        <p>
            Если при запуске этой программы ввести строку <b>1 2 3</b>, то список a будет равен <b>['1', '2', '3']</b>.
            Обратите внимание, что список будет состоять из строк, а не из чисел.
            Если хочется получить список именно из чисел, то можно затем элементы списка по одному преобразовать в числа:
        </p>
        <p><img src="images\listSRC\img11.png"></p>
        <p>
            Используя специальную магию Питона — генераторы — то же самое можно сделать в одну строку:
        </p>
        <p><img src="images\listSRC\img12.png"></p>
        <p>
            Объяснение того, как работает этот код, будет дано в следующем разделе. Если нужно считать список действительных чисел, то нужно заменить тип <b>int</b> на тип <b>float</b>.
        </p>
        <p>
            У метода <b>split()</b> есть необязательный параметр, который определяет, какая строка будет использоваться в качестве разделителя между элементами списка.
            Например, вызов метода <b>split('.')</b> вернет список, полученный разрезанием исходной строки по символам <b>'.'</b>:
        </p>
        <p><img src="images\listSRC\img13.png"></p>
        <p>
            В Питоне можно вывести список строк при помощи однострочной команды.
            Для этого используется метод строки <b>join</b>. У этого метода один параметр: список строк.
            В результате возвращается строка, полученная соединением элементов переданного списка в одну строку, при этом между элементами списка вставляется разделитель, равный той строке, к которой применяется метод.
            Мы знаем, что вы не поняли предыдущее предложение с первого раза.
            Поэтому смотрите примеры:
        </p>
        <p><img src="images\listSRC\img14.png"></p>
        <p>
            Если же список состоит из чисел, то придется использовать еще тёмную магию генераторов.
            Вывести элементы списка чисел, разделяя их пробелами, можно так:
        </p>
        <p><img src="images\listSRC\img15.png"></p>
        <p>
            Впрочем, если вы не любитель тёмной магии, то вы можете достичь того же эффекта, используя цикл <b>for</b>.
        </p>
    </li>
    <li>
        <h2>Генераторы списков</h2>
        <p>
            Для создания списка, заполненного одинаковыми элементами, можно использовать оператор повторения списка, например: 
        </p>
        <p><img src="images\listSRC\img16.png"></p>
        <p>
            Для создания списков, заполненных по более сложным формулам можно использовать <i>генераторы</i> выражения, позволяющие заполнить список некоторой формулой.
            Общий вид генератора следующий:
        </p>
        <p><b>[</b><i>выражение</i> <b>for</b> <i>переменная</i> <b>in</b> <i>последовательность</i><b>]</b></p>
        <p>
            где <b>переменная</b> — идентификатор некоторой переменной, <b>последовательность</b> — последовательность значений, который принимает данная переменная (это может быть список, строка или объект, полученный при помощи функции <b>range</b>), <b>выражение</b> — некоторое выражение, как правило, зависящее от использованной в генераторе переменной, которым будут заполнены элементы списка.  
        </p>
        <p>Вот несколько примеров использования генераторов.</p>
        <p>Создать список, состоящий из n нулей можно и при помощи генератора:</p>
        <p><img src="images\listSRC\img17.png"></p>
        <p>Создать список, заполненный квадратами целых чисел можно так:</p>
        <p><img src="images\listSRC\img18.png"></p>
        <p>
            Если нужно заполнить список квадратами чисел от 1 до <b>n</b>, то можно изменить параметры функции <b>range</b> на <b>range(1, n + 1)</b>
        </p>
        <p><img src="images\listSRC\img19.png"></p>
        <p>
            Вот так можно получить список, заполненный случайными числами от 1 до 9 (используя функцию <b>randrange</b> из модуля <b>random</b>):
        </p>
        <p><img src="images\listSRC\img20.png"></p>
        <p>
            А в этом примере список будет состоять из строк, считанных со стандартного ввода: сначала нужно ввести число элементов списка (это значение будет использовано в качестве аргумента функции <b>range</b>), потом — заданное количество строк:
        </p>
        <p><img src="images\listSRC\img21.png"></p>
    </li>
    <li>
        <h2>Срезы</h2>
        <p>
            Со списками, так же, как и со строками, можно делать срезы. А именно:
        </p>
        <p><b>A[i:j]</b>  срез из <b>j-i</b> элементов <b>A[i], A[i+1], ..., A[j-1]</b>.</p>
        <p><b>A[i:j:-1]</b>  срез из <b>i-j</b> элементов <b>A[i], A[i-1], ..., A[j+1]</b> (то есть меняется порядок элементов).</p>
        <p><b>A[i:j:k]</b>  срез с шагом <b>k: A[i], A[i+k], A[i+2*k],...</b> . Если значение <b>k &lt; 0</b>, то элементы идут в противоположном порядке.</p>
        <p>Каждое из чисел <b>i</b> или <b>j</b> может отсутствовать, что означает “начало строки” или “конец строки”</p>
        <p>
            Списки, в отличии от строк, являются <b>изменяемыми объектами</b> можно отдельному элементу списка присвоить новое значение. Но можно менять и целиком срезы. Например:
        </p>
        <p><img src="images\listSRC\img22.png"></p>
        <p>
            Получится список, у которого вместо двух элементов среза <b>A[2:4]</b> вставлен новый список уже из трех элементов. Теперь список стал равен <b>[1, 2, 7, 8, 9, 5]</b>.
        </p>
        <p><img src="images\listSRC\img23.png"></p>
        <p>
            Получится список <b>[40, 2, 30, 4, 20, 6, 10]</b>. Здесь <b>A[::-2]</b> — это список из элементов <b>A[-1], A[-3], A[-5], A[-7]</b>, которым присваиваются значения 10, 20, 30, 40 соответственно.
        </p>
        <p>
            Если не непрерывному срезу (то есть срезу с шагом <b>k</b>, отличному от 1), присвоить новое значение, то количество элементов в старом и новом срезе обязательно должно совпадать, в противном случае произойдет ошибка ValueError.
        </p>
        <p>Обратите внимание, <b>A[i]</b> — это элемент списка, а не срез!</p>
    </li>
    <li>
        <h2>Операции со списками</h2>
        <p>Со списками можно легко делать много разных операций.</p>
        <table>
            <tr>
                <td><b>x in A</b></td>
                <td>Проверить, содержится ли элемент в списке. Возвращает True или False</td>
            </tr>
            <tr>
                <td><b>x not in A</b></td>
                <td>То же самое, что not(x in A)</td>
            </tr>
            <tr>
                <td><b>min(A)</b></td>
                <td>Наименьший элемент списка</td>
            </tr>
            <tr>
                <td><b>max(A)</b></td>
                <td>Наибольший элемент списка</td>
            </tr>
            <tr>
                <td><b>A.index(x)</b></td>
                <td>Индекс первого вхождения элемента x в список, при его отсутствии генерирует исключение ValueError</td>
            </tr>
            <tr>
                <td><b>A.count(x)</b></td>
                <td>Количество вхождений элемента x в список</td>
            </tr>
        </table>
    </li>
</ol>
