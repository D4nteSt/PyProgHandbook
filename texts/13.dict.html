<h1>Словари</h1>
<p>
    Обычные списки (массивы) представляют собой набор пронумерованных элементов, то есть для обращения к какому-либо элементу списка необходимо указать его номер.
    Номер элемента в списке однозначно идентифицирует сам элемент.
    Но идентифицировать данные по числовым номерам не всегда оказывается удобно.
    Например, маршруты поездов в России идентифицируются численно-буквенным кодом (число и одна буква), также численно-буквенным кодом идентифицируются авиарейсы, то есть для хранения информации о рейсах поездов или самолетов в качестве идентификатора удобно было бы использовать не число, а текстовую строку.
</p>
<p>
    Структура данных, позволяющая идентифицировать ее элементы не по числовому индексу, а по произвольному, называется <i>словарем</i> или <i>ассоциативным массивом</i>.
    Соответствующая структура данных в языке Питон называется <b>dict</b>.
</p>
<p>
    Рассмотрим простой пример использования словаря.
    Заведем словарь <b>Capitals</b>, где индексом является название страны, а значением — название столицы этой страны.
    Это позволит легко определять по строке с названием страны ее столицу.
</p>
<p><img src="images\dictSRC\img1.png"></p>
<p>
    Итак, каждый элемент словаря состоит из двух объектов: <b>ключа и значения</b>.
    В нашем примере ключом является название страны, значением является название столицы.
    Ключ идентифицирует элемент словаря, значение является данными, которые соответствуют данному ключу.
    Значения ключей — уникальны, двух одинаковых ключей в словаре быть не может.
</p>
<p>
    В жизни широко распространены словари, например, привычные бумажные словари (толковые, орфографические, лингвистические).
    В них ключом является слово-заголовок статьи, а значением — сама статья.
    Для того, чтобы получить доступ к статье, необходимо указать слово-ключ.
</p>
<p>
    Другой пример словаря, как структуры данных — телефонный справочник.
    В нем ключом является имя, а значением — номер телефона.
    И словарь, и телефонный справочник хранятся так, что легко найти элемент словаря по известному ключу (например, если записи хранятся в алфавитном порядке ключей, то легко можно найти известный ключ, например, бинарным поиском), но если ключ неизвестен, а известно лишь значение, то поиск элемента с данным значением может потребовать последовательного просмотра всех элементов словаря.
</p>
<p>
    Особенностью ассоциативного массива является его динамичность: в него можно добавлять новые элементы с произвольными ключами и удалять уже существующие элементы.
    При этом размер используемой памяти пропорционален размеру ассоциативного массива.
    Доступ к элементам ассоциативного массива выполняется хоть и медленнее, чем к обычным массивам, но в целом довольно быстро.
</p>
<p>
    В языке Питон ключом может быть произвольный неизменяемый тип данных: целые и действительные числа, строки, кортежи.
    Ключом в словаре не может быть множество, но может быть элемент типа <b>frozenset</b>: специальный тип данных, являющийся аналогом типа <b>set</b>, который нельзя изменять после создания.
    Значением элемента словаря может быть любой тип данных, в том числе и изменяемый.
</p>
<ol>
    <li>
        <h2>Когда нужно использоват словари</h2>
        <p>Словари нужно использовать в следующих случаях:</p>
        <ul>
            <li>
                Подсчет числа каких-то объектов.
                В этом случае нужно завести словарь, в котором ключами являются объекты, а значениями — их количество.
            </li>
            <li>
                Хранение каких-либо данных, связанных с объектом.
                Ключи — объекты, значения — связанные с ними данные.
                Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря <b>Num['January'] = 1; Num['February'] = 2; ....</b>
            </li>
            <li>
                Установка соответствия между объектами (например, “родитель—потомок”).
                Ключ — объект, значение — соответствующий ему объект.
            </li>
            <li>
                Если нужен обычный массив, но максимальное значение индекса элемента очень велико, и при этом будут использоваться не все возможные индексы (так называемый “разреженный массив”), то можно использовать ассоциативный массив для экономии памяти.
            </li>
        </ul>
    </li>
    <li>
        <h2>Создание словаря</h2>
        <p>
            Пустой словарь можно создать при помощи функции <b>dict()</b> или пустой пары фигурных скобок <b>{}</b> (вот почему фигурные скобки нельзя использовать для создания пустого множества).
            Для создания словаря с некоторым набором начальных значений можно использовать следующие конструкции:
        </p>
        <p><img src="images\dictSRC\img2.png"></p>
        Первые два способа можно использовать только для создания небольших словарей, перечисляя все их элементы.
        Кроме того, во втором способе ключи передаются как именованные параметры функции <b>dict</b>, поэтому в этом случае ключи могут быть только строками, причем являющимися корректными идентификаторами. 
        В третьем и четвертом случае можно создавать большие словари, если в качестве аргументов передавать уже готовые списки, которые могут быть получены не обязательно перечислением всех элементов, а любым другим способом построены по ходу исполнения программы.
        В третьем способе функции <b>dict</b> нужно передать список, каждый элемент которого является кортежем из двух элементов: ключа и значения.
        В четвертом способе используется функция <b>zip</b>, которой передаются два списка одинаковой длины: список ключей и список значений.
    </li>
    <li>
        <h2>Работа с элементами словаря</h2>
        <p>
            Основная операция: получение значения элемента по ключу, записывается так же, как и для списков: <b>A[key]</b>.
            Если элемента с заданным ключом нет в словаре, то возникает исключение <b>KeyError</b>.
        </p>
        <p>
            Другой способ определения значения по ключу — метод <b>get: A.get(key)</b>.
            Если элемента с ключом <b>get</b> нет в словаре, то возвращается значение <b>None</b>.
            В форме записи с двумя аргументами <b>A.get(key, val)</b> метод возвращает значение <b>val</b>, если элемент с ключом <b>key</b> отсутствует в словаре.
        </p>
        <p>
            Проверить принадлежность элемента словарю можно операциями <b>in</b> и <b>not in</b>, как и для множеств.
        </p>
        <p>
            Для добавления нового элемента в словарь нужно просто присвоить ему какое-то значение: <b>A[key] = value</b>.
        </p>
        <p>
            Для удаления элемента из словаря можно использовать операцию <b>del A[key]</b> (операция возбуждает исключение <b>KeyError</b>, если такого ключа в словаре нет).
            Вот два безопасных способа удаления элемента из словаря.
        </p>
        <p><img src="images\dictSRC\img3.png"></p>
        <p>
            В первом случае мы предварительно проверяем наличие элемента, а во втором - перехватываем и обрабатываем исключение.
        </p>
        <p>
            Еще один способ удалить элемент из словаря: использование метода <b>pop: A.pop(key)</b>.
            Этот метод возвращает значение удаляемого элемента, если элемент с данным ключом отсутствует в словаре, то возбуждается исключение.
            Если методу <b>pop</b> передать второй параметр, то если элемент в словаре отсутствует, то метод <b>pop</b> возвратит значение этого параметра.
            Это позволяет проще всего организовать безопасное удаление элемента из словаря: <b>A.pop(key, None)</b>.
        </p>
    </li>
    <li>
        <h2>Перебор элементов словаря</h2>
        <p>
            Можно легко организовать перебор ключей всех элементов в словаре:
        </p>
        <p><img src="images\dictSRC\img4.png"></p>
        <p>
            Следующие методы возвращают представления элементов словаря.
            Представления во многом похожи на множества, но они изменяются, если менять значения элементов словаря.
            Метод <b>keys</b> возвращает представление ключей всех элементов, метод <b>values</b> возвращает представление всех значений, а метод <b>items</b> возвращает представление всех пар (кортежей) из ключей и значений.
        </p>
        <p>
            Соответственно, быстро проверить, есть ли значение <b>val</b> среди всех значений элементов словаря <b>A</b> можно так: <b>val in A.values()</b>, а организовать цикл так, чтобы в переменной <b>key</b> был ключ элемента, а в переменной <b>val</b>, было его значение можно так:
        </p>
        <p><img src="images\dictSRC\img5.png"></p>
    </li>
</ol>