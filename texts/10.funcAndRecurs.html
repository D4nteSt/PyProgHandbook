<h1>Функции и рекурсия</h1>
<ol>
    <li>
        <h2>Фукнции</h2>
        <p>
            Напомним, что в математике факториал числа n определяется как n! = 1 ⋅ 2 ⋅ ... ⋅ n.
            Например, 5! = 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 5 = 120.
            Ясно, что факториал можно легко посчитать, воспользовавшись циклом <b>for</b>.
            Представим, что нам нужно в нашей программе вычислять факториал разных чисел несколько раз (или в разных местах кода).
            Конечно, можно написать вычисление факториала один раз, а затем используя Copy-Paste вставить его везде, где это будет нужно. 
        </p>
        <p><img src="images\funcSRC\img1.png"></p>
        <p>
            Однако, если мы ошибёмся один раз в начальном коде, то потом эта ошибка попадёт в код во все места, куда мы скопировали вычисление факториала.
            Да и вообще, код занимает больше места, чем мог бы.
            Чтобы избежать повторного написания одной и той же логики, в языках программирования существуют функции.
        </p>
        <p>
            Функции — это такие участки кода, которые изолированы от остальной программы и выполняются только тогда, когда вызываются.
            Вы уже встречались с функциями sqrt(), len() и print().
            Они все обладают общим свойством: они могут принимать параметры (ноль, один или несколько), и они могут возвращать значение (хотя могут и не возвращать).
            Например, функция sqrt() принимает один параметр и возвращает значение (корень числа).
            Функция print() принимает переменное число параметров и ничего не возвращает. 
        </p>
        <p>
            Покажем, как написать функцию <b>factorial()</b>, которая принимает один параметр — число, и возвращает значение — факториал этого числа.
        </p>
        <p><img src="images\funcSRC\img2.png"></p>
        <p>
            Дадим несколько объяснений.
            Во-первых, код функции должен размещаться в начале программы, вернее, до того места, где мы захотим воспользоваться функцией <b>factorial()</b>.
            Первая строчка этого примера является описанием нашей функции.
            <b>factorial</b> — идентификатор, то есть <b>имя</b> нашей <b>функции</b>.
            После идентификатора в круглых скобках идет <b>список параметров</b>, которые получает наша функция.
            Список состоит из перечисленных через запятую идентификаторов параметров.
            В нашем случае список состоит из одной величины <b>n</b>.
            В конце строки ставится двоеточие.
        </p>
        <p>
            Далее идет <b>тело функции</b>, оформленное в виде блока, то есть с <b>отступом</b>.
            Внутри функции вычисляется значение факториала числа <b>n</b> и оно сохраняется в переменной <b>res</b>.
            Функция завершается инструкцией <b>return res</b>, которая завершает работу функции и возвращает значение переменной <b>res</b>.
        </p>
        <p>
            Инструкция <b>return</b> может встречаться в произвольном месте функции, ее исполнение завершает работу функции и возвращает указанное значение в место вызова.
            Если функция не возвращает значения, то инструкция <b>return</b> используется без возвращаемого значения.
            В функциях, которым не нужно возвращать значения, инструкция <b>return</b> может отсутствовать.
        </p>
        <p>
            Приведём ещё один пример. Напишем функцию <b>max()</b>, которая принимает два числа и возвращает максимальное из них (на самом деле, такая функция уже встроена в Питон).
        </p>
        <p><img src="images\funcSRC\img3.png"></p>
        <p>
            Теперь можно написать функцию <b>max3()</b>, которая принимает три числа и возвращает максимальное их них.
        </p>
        <p><img src="images\funcSRC\img4.png"></p>
        <p>
            Встроенная функция <b>max()</b> в Питоне может принимать переменное число аргументов и возвращать максимум из них.
            Приведём пример того, как такая функция может быть написана.
        </p>
        <p><img src="images\funcSRC\img5.png"></p>
        <p>
            Все переданные в эту функцию параметры соберутся в один кортеж с именем <b>a</b>, на что указывает звёздочка в строке объявления функции.
        </p>
    </li>
    <li>
        <h2>Локальные и глобальные переменные</h2>
        <p>Внутри функции можно использовать переменные, объявленные вне этой функции.</p>
        <p><img src="images\funcSRC\img6.png"></p>
        <p>
            Здесь переменной a присваивается значение 1, и функция <b>f()</b> печатает это значение, несмотря на то, что до объявления функции <b>f</b> эта переменная не инициализируется.
            В момент вызова функции <b>f()</b> переменной <b>a</b> уже присвоено значение, поэтому функция <b>f()</b> может вывести его на экран.
        </p>
        <p>
            Такие переменные (объявленные вне функции, но доступные внутри функции) называются <i>глобальными</i>.
        </p>
        <p>
            Но если инициализировать какую-то переменную внутри функции, использовать эту переменную вне функции не удастся.
            Например:
        </p>
        <p><img src="images\funcSRC\img7.png"></p>
        <p>
            Получим ошибку <b>NameError: name 'a' is not define</b>d.
            Такие переменные, объявленные внутри функции, называются <i>локальными</i>.
            Эти переменные становятся недоступными после выхода из функции. 
        </p>
        <p>
            Интересным получится результат, если попробовать изменить значение глобальной переменной внутри функции:
        </p>
        <p><img src="images\funcSRC\img8.png"></p>
        Будут выведены числа 1 и 0. Несмотря на то, что значение переменной <b>a</b> изменилось внутри функции, вне функции оно осталось прежним!
        Это сделано в целях “защиты” глобальных переменных от случайного изменения из функции.
        Например, если функция будет вызвана из цикла по переменной <b>i</b>, а в этой функции будет использована переменная <b>i</b> также для организации цикла, то эти переменные должны быть различными.
        Если вы не поняли последнее предложение, то посмотрите на следующий код и подумайте, как бы он работал, если бы внутри функции изменялась переменная <b>i</b>.
        <p><img src="images\funcSRC\img9.png"></p>
        <p>Если бы глобальная переменная i изменялась внутри функции, то мы бы получили вот что:</p>
        <p><img src="images\funcSRC\img10.png"></p>
        <p>
            Итак, если внутри функции модифицируется значение некоторой переменной, то переменная с таким именем становится локальной переменной, и ее модификация не приведет к изменению глобальной переменной с таким же именем.
        </p>
        <p>
            Более формально: интерпретатор Питон считает переменную локальной для данной функции, если в её коде есть хотя бы одна инструкция, модифицирующая значение переменной, то эта переменная считается локальной и не может быть использована до инициализации.
            Инструкция, модифицирующая значение переменной — это операторы =, +=, а также использование переменной в качестве параметра цикла <b>for</b>. При этом даже если инструкция, модифицирующая переменную никогда не будет выполнена, интерпретатор это проверить не может, и переменная все равно считается локальной.
            Пример:
        </p>
        <p><img src="images\funcSRC\img11.png"></p>
        <p>
            Возникает ошибка: <b>UnboundLocalError: local variable 'a' referenced before assignment</b>.
            А именно, в функции <b>f()</b> идентификатор a становится локальной переменной, т.к. в функции есть команда, модифицирующая переменную <b>a</b>, пусть даже никогда и не выполняющийся (но интерпретатор не может это отследить).
            Поэтому вывод переменной <b>a</b> приводит к обращению к неинициализированной локальной переменной.
        </p>
        <p>
            Чтобы функция могла изменить значение глобальной переменной, необходимо объявить эту переменную внутри функции, как глобальную, при помощи ключевого слова <b>global</b>
        </p>
        <p><img src="images\funcSRC\img12.png"></p>
        <p>
            В этом примере на экран будет выведено 1 1, так как переменная a объявлена, как глобальная, и ее изменение внутри функции приводит к тому, что и вне функции переменная будет доступна.
        </p>
        <p>
            Тем не менее, лучше не изменять значения глобальных переменных внутри функции.
            Если ваша функция должна поменять какую-то переменную, пусть лучше она вернёт это значением, и вы сами при вызове функции явно присвоите в переменную это значение.
            Если следовать этим правилам, то функции получаются независимыми от кода, и их можно легко копировать из одной программы в другую.
        </p>
        <p>
            Например, пусть ваша программа должна посчитать факториал вводимого числа, который вы потом захотите сохранить в переменной <b>f</b>.
            Вот как это <u><b>не стоит</b></u> делать:          
        </p>
        <p><img src="images\funcSRC\img13.png"></p>
        <p>
            Этот код написан плохо, потому что его трудно использовать ещё один раз.
            Если вам завтра понадобится в другой программе использовать функцию «факториал», то вы не сможете просто скопировать эту функцию отсюда и вставить в вашу новую программу.
            Вам придётся поменять то, как она возвращает посчитанное значение.
        </p>
        <p>
            Гораздо <u><b>лучше</b></u> переписать этот пример так:
        </p>
        <p><img src="images\funcSRC\img14.png"></p>
        <p>
            Если нужно, чтобы функция вернула не одно значение, а два или более, то для этого функция может вернуть список из двух или нескольких значений:
        </p>
        <p><img src="images\funcSRC\img15.png"></p>
        <p>
            Тогда результат вызова функции можно будет использовать во множественном присваивании:
        </p>
        <p><img src="images\funcSRC\img16.png"></p>
    </li>
    <li>
        <h2>Рекурсия</h2>
        <p><img src="images\funcSRC\img17.png"></p>
        <p>
            Как мы видели выше, функция может вызывать другую функцию.
            Но функция также может вызывать и саму себя!
            Рассмотрим это на примере функции вычисления факториала.
            Хорошо известно, что 0!=1, 1!=1.
            А как вычислить величину n! для большого n?
            Если бы мы могли вычислить величину (n-1)!, то тогда мы легко вычислим n!, поскольку n!=n⋅(n-1)!. 
            Но как вычислить (n-1)!?
            Если бы мы вычислили (n-2)!, то мы сможем вычисли и (n-1)!=(n-1)⋅(n-2)!.
            А как вычислить (n-2)!?
            Если бы...
            В конце концов, мы дойдем до величины 0!, которая равна 1.
            Таким образом, для вычисления факториала мы можем использовать значение факториала для меньшего числа.
            Это можно сделать и в программе на Питоне:
        </p>
        <p><img src="images\funcSRC\img18.png"></p>
        <p>
            Подобный прием (вызов функцией самой себя) называется <i>рекурсией</i>, а сама функция называется <i>рекурсивной</i>.
        </p>
        <p>
            Рекурсивные функции являются мощным механизмом в программировании.
            К сожалению, они не всегда эффективны.
            Также часто использование рекурсии приводит к ошибкам.
            Наиболее распространенная из таких ошибок – бесконечная рекурсия, когда цепочка вызовов функций никогда не завершается и продолжается, пока не кончится свободная память в компьютере.
            Две наиболее распространенные причины для бесконечной рекурсии:
        </p>
        <ol>
            <li>
                <p>
                    Неправильное оформление выхода из рекурсии. Например, если мы в программе вычисления факториала забудем поставить проверку <b>if n == 0</b>, то <b>factorial(0)</b> вызовет <b>factorial(-1)</b>, тот вызовет <b>factorial(-2)</b> и т. д.
                </p>
            </li>
            <li>
                <p>
                    Рекурсивный вызов с неправильными параметрами. Например, если функция <b>factorial(n)</b> будет вызывать <b>factorial(n)</b>, то также получится бесконечная цепочка.
                </p>
            </li>
        </ol>
        <p>
            Поэтому при разработке рекурсивной функции необходимо прежде всего оформлять условия завершения рекурсии и думать, почему рекурсия когда-либо завершит работу.
        </p>
    </li>
</ol>